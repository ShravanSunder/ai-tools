#!/bin/bash
# .devcontainer/init-firewall.sh
# Container-only, fail-hard egress firewall using dnsmasq + ipset + iptables.
# IPv4 is restricted to an allowlist; IPv6 is left unrestricted per policy.

set -euo pipefail

echo "üõ°Ô∏è Initializing Egress Firewall..."

# --- 1. Hard Safety Guards ---
if [[ "$(uname)" != "Linux" ]]; then
    echo "‚ùå ERROR: This script requires Linux. Refusing to run on $(uname)."
    exit 1
fi

IS_CONTAINER=false
if [ -f /.dockerenv ] || [ -f /run/.containerenv ]; then
    IS_CONTAINER=true
elif grep -iqE "docker|containerd|kubepods" /proc/1/cgroup 2>/dev/null; then
    IS_CONTAINER=true
fi

if [ "$IS_CONTAINER" = false ]; then
    echo "‚ùå ERROR: Refusing to run outside of a container environment."
    exit 1
fi

# --- 2. Read Allowlist ---
ALLOWLIST_FILE="${FIREWALL_ALLOWLIST:-$(pwd)/.devcontainer/init-firewall.allowlist.base.txt}"
if [[ ! -f "$ALLOWLIST_FILE" ]]; then
    echo "‚ùå ERROR: Allowlist file not found at $ALLOWLIST_FILE"
    exit 1
fi

echo "  - Reading allowlist from: $ALLOWLIST_FILE"
DOMAINS=()
GITHUB_META_PRELOAD=false

while IFS= read -r line || [[ -n "$line" ]]; do
    # Trim whitespace
    line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    # Skip blanks and comments
    [[ -z "$line" || "$line" == "#"* ]] && continue
    
    # Directives
    if [[ "$line" == "@github_meta" ]]; then
        GITHUB_META_PRELOAD=true
        continue
    fi
    
    # Normalize *.foo.com -> foo.com (dnsmasq matches subdomains)
    normalized=$(echo "$line" | sed 's/^\*\.//')
    
    # Basic validation
    if [[ ! "$normalized" =~ ^[a-zA-Z0-9.-]+$ ]]; then
        echo "‚ùå ERROR: Invalid domain entry: $line"
        exit 1
    fi
    
    DOMAINS+=("$normalized")
done < "$ALLOWLIST_FILE"

# --- 3. Prep dnsmasq and ipset ---
IPSET_NAME="luna_allowed_v4"
echo "  - Preparing ipset: $IPSET_NAME"
ipset create "$IPSET_NAME" hash:net -! 

# Capture upstream resolvers from /etc/resolv.conf before we touch it
# We look for 'nameserver' lines, excluding loopback
UPSTREAM_RESOLVERS=$(grep '^nameserver' /etc/resolv.conf | grep -v '127.0.0.1' | awk '{print $2}' || true)
if [[ -z "$UPSTREAM_RESOLVERS" ]]; then
    # Fallback to Google DNS if none found (unlikely in Docker but safer)
    echo "  ‚ö†Ô∏è No upstream resolvers found in /etc/resolv.conf, falling back to 8.8.8.8"
    UPSTREAM_RESOLVERS="8.8.8.8"
fi

DNSMASQ_CONF="/tmp/dnsmasq.luna.conf"
cat > "$DNSMASQ_CONF" <<EOF
# Automatically generated by init-firewall.sh
listen-address=127.0.0.1
port=53
bind-interfaces
no-hosts
cache-size=1000
log-queries
EOF

for resolver in $UPSTREAM_RESOLVERS; do
    echo "server=$resolver" >> "$DNSMASQ_CONF"
done

for domain in "${DOMAINS[@]}"; do
    echo "ipset=/$domain/$IPSET_NAME" >> "$DNSMASQ_CONF"
done

# Kill any existing dnsmasq on port 53
pkill -x dnsmasq || true

echo "  - Starting dnsmasq..."
dnsmasq --conf-file="$DNSMASQ_CONF"

# --- 4. Force DNS through loopback ---
echo "  - Redirecting DNS to local dnsmasq..."
# Backup original resolv.conf if not already backed up
if [[ ! -f /etc/resolv.conf.luna.bak ]]; then
    cp /etc/resolv.conf /etc/resolv.conf.luna.bak
fi
echo "nameserver 127.0.0.1" > /etc/resolv.conf

# --- 5. Surgical iptables ---
CHAIN_NAME="LUNA_EGRESS"
echo "  - Configuring iptables chain: $CHAIN_NAME"

# Create and flush the chain
iptables -N "$CHAIN_NAME" 2>/dev/null || iptables -F "$CHAIN_NAME"

# Jump to our chain at the top of OUTPUT (idempotent)
if ! iptables -C OUTPUT -j "$CHAIN_NAME" 2>/dev/null; then
    iptables -I OUTPUT 1 -j "$CHAIN_NAME"
fi

# Allow loopback
iptables -A "$CHAIN_NAME" -o lo -j ACCEPT
# Allow established/related
iptables -A "$CHAIN_NAME" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
# Allow DNS to local dnsmasq
iptables -A "$CHAIN_NAME" -p udp --dport 53 -d 127.0.0.1 -j ACCEPT
iptables -A "$CHAIN_NAME" -p tcp --dport 53 -d 127.0.0.1 -j ACCEPT

# Allow dnsmasq to talk to upstream resolvers
for resolver in $UPSTREAM_RESOLVERS; do
    iptables -A "$CHAIN_NAME" -p udp --dport 53 -d "$resolver" -j ACCEPT
    iptables -A "$CHAIN_NAME" -p tcp --dport 53 -d "$resolver" -j ACCEPT
done

# Allow traffic to destinations in our ipset
iptables -A "$CHAIN_NAME" -m set --match-set "$IPSET_NAME" dst -j ACCEPT

# Reject everything else in IPv4 OUTPUT
# We use REJECT for cleaner behavior than DROP inside a container
iptables -A "$CHAIN_NAME" -j REJECT --reject-with icmp-port-unreachable

# --- 6. GitHub Meta Preload ---
if [ "$GITHUB_META_PRELOAD" = true ]; then
    echo "  - Preloading GitHub Meta CIDRs..."
    META_JSON=$(curl -s https://api.github.com/meta)
    if [[ -z "$META_JSON" ]]; then
        echo "‚ùå ERROR: Failed to fetch GitHub Meta"
        exit 1
    fi
    
    # Extract IPv4 CIDRs from 'git' and 'api' fields
    # We use jq (installed in Dockerfile)
    echo "    - Adding GitHub 'git' CIDRs..."
    for cidr in $(echo "$META_JSON" | jq -r '.git[]' | grep -v ':'); do
        ipset add "$IPSET_NAME" "$cidr" -!
    done
    
    echo "    - Adding GitHub 'api' CIDRs..."
    for cidr in $(echo "$META_JSON" | jq -r '.api[]' | grep -v ':'); do
        ipset add "$IPSET_NAME" "$cidr" -!
    done
fi

echo "‚úÖ Firewall initialized successfully."
