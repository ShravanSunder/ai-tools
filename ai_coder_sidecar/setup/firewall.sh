#!/bin/bash
# init-firewall.sh
# Container-only, fail-hard egress firewall using dnsmasq + ipset + iptables.
# IPv4 is restricted to an allowlist; IPv6 is left unrestricted per policy.
#
# Supports two-level allowlist:
#   - Base allowlist (always-on domains: AI APIs, package registries)
#   - Toggle allowlist (temporarily enabled domains: Jira, Notion, etc.)
#
# Usage:
#   init-firewall.sh           # Full initialization (first run)
#   init-firewall.sh --reload  # Reload allowlists without full restart

set -euo pipefail

# --- Configuration ---
IPSET_NAME="aidev_allowed_v4"
CHAIN_NAME="AIDEV_EGRESS"
DNSMASQ_CONF="/tmp/dnsmasq.aidev.conf"
RESOLV_BACKUP="/etc/resolv.conf.aidev.bak"

# --- Helper Functions ---
log_info() { echo "  - $1"; }
log_error() { echo "âŒ ERROR: $1" >&2; }
log_success() { echo "âœ… $1"; }

# Read domains from an allowlist file into the DOMAINS array
# Usage: read_allowlist_file "/path/to/file.txt"
read_allowlist_file() {
    local file="$1"
    [[ ! -f "$file" ]] && return 0
    
    log_info "Reading allowlist: $file"
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Trim whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip blanks and comments
        [[ -z "$line" || "$line" == "#"* ]] && continue
        
        # Directives
        if [[ "$line" == "@github_meta" ]]; then
            GITHUB_META_PRELOAD=true
            continue
        fi
        
        # Normalize *.foo.com -> foo.com (dnsmasq matches subdomains)
        local normalized
        normalized=$(echo "$line" | sed 's/^\*\.//')
        
        # Basic validation
        if [[ ! "$normalized" =~ ^[a-zA-Z0-9.-]+$ ]]; then
            log_error "Invalid domain entry: $line"
            exit 1
        fi
        
        DOMAINS+=("$normalized")
    done < "$file"
}

# Generate dnsmasq configuration
generate_dnsmasq_conf() {
    cat > "$DNSMASQ_CONF" <<EOF
# Automatically generated by init-firewall.sh
listen-address=127.0.0.1
port=53
bind-interfaces
no-hosts
cache-size=1000
log-queries
EOF

    for resolver in $UPSTREAM_RESOLVERS; do
        echo "server=$resolver" >> "$DNSMASQ_CONF"
    done

    for domain in "${DOMAINS[@]}"; do
        echo "ipset=/$domain/$IPSET_NAME" >> "$DNSMASQ_CONF"
    done
}

# Load GitHub Meta CIDRs into ipset
load_github_meta() {
    log_info "Preloading GitHub Meta CIDRs..."
    local meta_json
    meta_json=$(curl -s https://api.github.com/meta)
    if [[ -z "$meta_json" ]]; then
        log_error "Failed to fetch GitHub Meta"
        exit 1
    fi
    
    log_info "  Adding GitHub 'git' CIDRs..."
    for cidr in $(echo "$meta_json" | jq -r '.git[]' | grep -v ':'); do
        ipset add "$IPSET_NAME" "$cidr" -!
    done
    
    log_info "  Adding GitHub 'api' CIDRs..."
    for cidr in $(echo "$meta_json" | jq -r '.api[]' | grep -v ':'); do
        ipset add "$IPSET_NAME" "$cidr" -!
    done
}

# --- 1. Hard Safety Guards ---
check_environment() {
    if [[ "$(uname)" != "Linux" ]]; then
        log_error "This script requires Linux. Refusing to run on $(uname)."
        exit 1
    fi

    local is_container=false
    if [ -f /.dockerenv ] || [ -f /run/.containerenv ]; then
        is_container=true
    elif grep -iqE "docker|containerd|kubepods" /proc/1/cgroup 2>/dev/null; then
        is_container=true
    fi

    if [ "$is_container" = false ]; then
        log_error "Refusing to run outside of a container environment."
        exit 1
    fi
}

# --- 2. Resolve Allowlist Files ---
resolve_allowlist_files() {
    # Base allowlist (required) - "always" allowed domains
    BASE_ALLOWLIST="${FIREWALL_ALLOWLIST:-}"
    if [[ -z "$BASE_ALLOWLIST" ]]; then
        # Try common locations
        for candidate in \
            "$(pwd)/.devcontainer/firewall-allowlist-always.base.txt" \
            "/usr/local/etc/firewall/firewall-allowlist-always.base.txt" \
            "${SCRIPT_DIR:-}/firewall-allowlist-always.base.txt"
        do
            if [[ -f "$candidate" ]]; then
                BASE_ALLOWLIST="$candidate"
                break
            fi
        done
    fi

    if [[ -z "$BASE_ALLOWLIST" || ! -f "$BASE_ALLOWLIST" ]]; then
        log_error "Base allowlist file not found. Set FIREWALL_ALLOWLIST env var."
        exit 1
    fi

    # Toggle allowlists (optional) - temporarily enabled domains
    # Two files: .base.txt (tracked, project defaults) and .tmp.txt (gitignored, runtime changes)
    local base_dir
    base_dir=$(dirname "$BASE_ALLOWLIST")
    
    # Toggle base is in setup/ (tracked), toggle tmp is in .generated/ (same as compiled file)
    local sidecar_dir
    sidecar_dir=$(dirname "$base_dir")  # Go up from .generated to ai_coder_sidecar
    TOGGLE_ALLOWLIST_BASE="${FIREWALL_ALLOWLIST_TOGGLE:-$sidecar_dir/setup/firewall-allowlist-toggle.base.txt}"
    TOGGLE_ALLOWLIST_TMP="$base_dir/firewall-allowlist-toggle.tmp.txt"
}

# --- 3. Capture Upstream Resolvers ---
capture_upstream_resolvers() {
    # Use backup if available, otherwise current resolv.conf
    local resolv_file="/etc/resolv.conf"
    [[ -f "$RESOLV_BACKUP" ]] && resolv_file="$RESOLV_BACKUP"
    
    UPSTREAM_RESOLVERS=$(grep '^nameserver' "$resolv_file" | grep -v '127.0.0.1' | awk '{print $2}' || true)
    if [[ -z "$UPSTREAM_RESOLVERS" ]]; then
        echo "  âš ï¸ No upstream resolvers found, falling back to 8.8.8.8"
        UPSTREAM_RESOLVERS="8.8.8.8"
    fi
}

# --- RELOAD MODE ---
# Fast path: reload allowlists and restart dnsmasq without touching iptables
do_reload() {
    echo "ðŸ”„ Reloading firewall allowlists..."
    
    check_environment
    resolve_allowlist_files
    capture_upstream_resolvers
    
    # Read all domains from all files (base + toggle.base + toggle.tmp)
    DOMAINS=()
    GITHUB_META_PRELOAD=false
    read_allowlist_file "$BASE_ALLOWLIST"
    [[ -f "$TOGGLE_ALLOWLIST_BASE" ]] && read_allowlist_file "$TOGGLE_ALLOWLIST_BASE"
    [[ -f "$TOGGLE_ALLOWLIST_TMP" ]] && read_allowlist_file "$TOGGLE_ALLOWLIST_TMP"
    
    log_info "Total domains loaded: ${#DOMAINS[@]}"
    
    # Flush and recreate ipset (keeps iptables rule intact)
    log_info "Flushing ipset: $IPSET_NAME"
    ipset flush "$IPSET_NAME" 2>/dev/null || ipset create "$IPSET_NAME" hash:net
    
    # Regenerate dnsmasq config
    generate_dnsmasq_conf
    
    # Restart dnsmasq with new config
    log_info "Restarting dnsmasq..."
    pkill -x dnsmasq || true
    sleep 0.5
    dnsmasq --conf-file="$DNSMASQ_CONF"
    
    # Load GitHub Meta if requested
    if [ "$GITHUB_META_PRELOAD" = true ]; then
        load_github_meta
    fi
    
    log_success "Firewall reloaded successfully."
}

# --- FULL INIT MODE ---
do_full_init() {
    echo "ðŸ›¡ï¸ Initializing Egress Firewall..."
    
    check_environment
    resolve_allowlist_files
    
    # Read all domains from all files (base + toggle.base + toggle.tmp)
    DOMAINS=()
    GITHUB_META_PRELOAD=false
    read_allowlist_file "$BASE_ALLOWLIST"
    [[ -f "$TOGGLE_ALLOWLIST_BASE" ]] && read_allowlist_file "$TOGGLE_ALLOWLIST_BASE"
    [[ -f "$TOGGLE_ALLOWLIST_TMP" ]] && read_allowlist_file "$TOGGLE_ALLOWLIST_TMP"
    
    log_info "Total domains loaded: ${#DOMAINS[@]}"
    
    # --- Prep ipset ---
    log_info "Preparing ipset: $IPSET_NAME"
    ipset create "$IPSET_NAME" hash:net -!
    ipset flush "$IPSET_NAME"
    
    # --- Capture upstream resolvers ---
    capture_upstream_resolvers
    
    # --- Generate dnsmasq config ---
    generate_dnsmasq_conf
    
    # Kill any existing dnsmasq on port 53
    pkill -x dnsmasq || true
    
    log_info "Starting dnsmasq..."
    dnsmasq --conf-file="$DNSMASQ_CONF"
    
    # --- Force DNS through loopback ---
    log_info "Redirecting DNS to local dnsmasq..."
    if [[ ! -f "$RESOLV_BACKUP" ]]; then
        cp /etc/resolv.conf "$RESOLV_BACKUP"
    fi
    echo "nameserver 127.0.0.1" > /etc/resolv.conf
    
    # --- Surgical iptables ---
    log_info "Configuring iptables chain: $CHAIN_NAME"
    
    # Create and flush the chain
    iptables -N "$CHAIN_NAME" 2>/dev/null || iptables -F "$CHAIN_NAME"
    
    # Jump to our chain at the top of OUTPUT (idempotent)
    if ! iptables -C OUTPUT -j "$CHAIN_NAME" 2>/dev/null; then
        iptables -I OUTPUT 1 -j "$CHAIN_NAME"
    fi
    
    # Allow loopback
    iptables -A "$CHAIN_NAME" -o lo -j ACCEPT
    # Allow established/related
    iptables -A "$CHAIN_NAME" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
    # Allow DNS to local dnsmasq
    iptables -A "$CHAIN_NAME" -p udp --dport 53 -d 127.0.0.1 -j ACCEPT
    iptables -A "$CHAIN_NAME" -p tcp --dport 53 -d 127.0.0.1 -j ACCEPT
    
    # Allow dnsmasq to talk to upstream resolvers
    for resolver in $UPSTREAM_RESOLVERS; do
        iptables -A "$CHAIN_NAME" -p udp --dport 53 -d "$resolver" -j ACCEPT
        iptables -A "$CHAIN_NAME" -p tcp --dport 53 -d "$resolver" -j ACCEPT
    done
    
    # Allow traffic to destinations in our ipset
    iptables -A "$CHAIN_NAME" -m set --match-set "$IPSET_NAME" dst -j ACCEPT
    
    # Reject everything else in IPv4 OUTPUT
    iptables -A "$CHAIN_NAME" -j REJECT --reject-with icmp-port-unreachable
    
    # --- GitHub Meta Preload ---
    if [ "$GITHUB_META_PRELOAD" = true ]; then
        load_github_meta
    fi
    
    log_success "Firewall initialized successfully."
}

# --- Main ---
case "${1:-}" in
    --reload|-r)
        do_reload
        ;;
    --help|-h)
        echo "Usage: $0 [--reload]"
        echo ""
        echo "  (no args)   Full firewall initialization"
        echo "  --reload    Reload allowlists without full restart"
        echo ""
        echo "Environment variables:"
        echo "  FIREWALL_ALLOWLIST        Path to base allowlist file"
        echo "  FIREWALL_ALLOWLIST_TOGGLE Path to toggle allowlist file (optional)"
        ;;
    *)
        do_full_init
        ;;
esac
